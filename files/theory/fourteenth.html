<html>
<body>
<p><font size = '10' face = 'Times New Roman'><strong>Расширение возможностей трассировщика лучей</strong></font></p>
<p><font size = '5' face = 'Times New Roman'>В завершение рассмотрим несколько итересных тем, которые мы еще не затронули: оптимизацию быстродействия, 
использование иных фигур, помимо сфер, моделирование объектов с помощью конструктивной блочной геометрии, поддержку прозрачных поверхностей и суперсемплинг 
(избыточная выборка сглаживания). </font></p>
<p><font size = '6' face = 'Times New Roman'><strong>Распараллеливание</strong></font></p>
<p><font size = '5' face = 'Times New Roman'>Самый очевидный способ ускорить трассировщик — это выполнить одновременную трассировку множества лучей. Каждый исходящий из камеры луч 
независим от других, и данные сцены предполагают только считывание, можно трассировать по одному лучу на ядро ЦПУ без дополнительных издержек или сложностей с синхронизацией. 
Вообще, в силу своей внутренней природы трассировщики лучей относятся к классу чрезвычайно параллелизуемых алгоритмов. <br><br>
Но порождать поток для каждого луча — не лучшая идея. Это создаст излишнюю нагрузку и перекроет весь прирост скорости. Разумнее будет создать набор «задач». Каждая из них будет 
отвечать за трассировку части холста (прямоугольной области с точностью до пикселя) и распределять эти задачи по потокам воркеров на физических ядрах по мере их доступности. </font>
<p><font size = '6' face = 'Times New Roman'><strong>Кэширование неизменяемых значений</strong></font></p>
<p><font size = '5' face = 'Times New Roman'>Кэширование — это способ избежать постоянного повторения одинаковых вычислений. Когда они затратны, а использовать их результат 
планируется не единожды, лучше сохранить (кэшировать) его значение и потом при надобности использовать уже в готовом виде. Это особенно актуально, когда результат изменяется редко.</font></p>
<p><font size = '6' face = 'Times New Roman'><strong>Оптимизация теней</strong></font></p>
<p><font size = '5' face = 'Times New Roman'>Когда точка поверхности находится в тени из-за преграды на пути к свету, вероятность, что соседняя точка тоже будет в тени 
того же объекта, высока (это называется совокупностью теней). Посмотрите пример на рис. 6.1.
<center><img src = "C:/Program Files (x86)/Qt Project/RayTracing/files/theory/img/6.1.png"></center>
<center><strong>Рис. 6.1.</strong>  Близкорасположенные точки, вероятнее всего, будут в тени одного объекта</center><br>
Когда мы ищем объекты между точкой и источником света, чтобы определить, находится ли эта точка в тени, мы проверяем наличие пересечений с остальными объектами сцены. 
Но если мы знаем, что соседняя точка в тени какого-то объекта, то сначала можно проверить наличие пересечений именно с ним. Если оно есть, 
то остальные объекты можно не проверять. Если пересечения нет, мы просто проверяем остальные. <br><br>
Точно так же при поиске пересечений луча с объектом, чтобы узнать, находится ли точка в тени, не нужно искать ближайшее пересечение. Достаточно знать о наличии 
хотя бы одного, так как оно уже будет считаться преградой на пути света к точке. Поэтому можно написать особую версию ClosestIntersection, возвращающую 
результат при первом обнаружении любого пересечения. И не нужно вычислять и возвращать closest_t, ведь достаточно просто вернуть булево значение. </font></p>
<p><font size = '6' face = 'Times New Roman'><strong>Иерархические структуры</strong></font></p>
<p><font size = '5' face = 'Times New Roman'>Очень затратно вычислять пересечение луча с каждой сферой сцены. Есть много разных структур данных, позволяющих отбросить 
целые группы объектов и избавляющих от необходимости вычисления их пересечений по отдельности. <br><br>
Представим, что у нас есть несколько близко расположенных сфер. Можно вычислить центр и радиус наименьшей, содержащей их все. Если луч не пересекается с этой <i>ограничивающей сферой</i>, 
можно сделать вывод, что он не пересекает и находящиеся внутри нее, затратив на это всего одну операцию вычисления. 
Если пересечение будет найдено, придется проверять, пересекает ли луч любую из внутренних сфер. <br><br>
Можно углубиться и создать несколько уровней ограничивающих сфер (групп, состоящих из других групп сфер), сформировав иерархию. Полностью обойти ее понадобится только в случае 
пересечения одной из сфер лучом.
<p><font size = '6' face = 'Times New Roman'><strong>Прореживание</strong></font></p>
<p><font size = '5' face = 'Times New Roman'>Вот простой способ ускорить работу трассировщика лучей в N раз: вычислять в N раз меньше пикселей! Для каждого пикселя холста 
мы трассируем один луч через окно просмотра, чтобы сэмплировать цвет идущего из этого направления света. Если бы лучей у нас было меньше, чем пикселей, это бы означало выполнение 
прореживания(subsampling) сцены. </font></p>
<p><font size = '7' face = 'Times New Roman'><strong>Поддержка других примитивов</strong></font></p>
<p><font size = '5' face = 'Times New Roman'>Ранее мы использовали сферы, потому что уравнения для нахождения пересечений между лучами и сферами несложные. 
Но, когда у вас уже есть базовый трассировщик, способный отрисовывать сферы, добавить другие примитивы не составит труда. <br><br>
Обратите внимание, что TraceRay должен иметь возможность вычислить для луча и любого объекта всего два элемента: значение <i>t</i> для ближайшего их пересечения 
и нормаль в нем. Все остальное в трассировщике от объектов не зависит. <br><br>
Треугольник тоже можно отнести к удобным в рендеринге фигурам. Он простейший из возможных многоугольников — из него можно строить любые многоугольники. 
Так как математически ими тоже легко управлять, они отлично подходят для представления аппроксимации более сложных поверхностей. <br><br>
Для добавления поддержки треугольников в трассировщик нужно просто изменить TraceRay. Сначала мы вычисляем пересечение между лучом (заданным его источником и направлением) 
и плоскостью с треугольником (заданным его нормалью и расстоянием от начала координат). <br><br>
Плоскости бесконечно велики, поэтому лучи почти всегда будут пересекать любую из них (за исключением взаимной параллельности и случая, когда луч удаляется от поверхности). 
Шаг второй: определить, находится ли пересечение луча и плоскости внутри треугольника. Это можно сделать разными способами, в том числе использовать барицентрические координаты 
или векторные произведения для проверки того, находится ли точка «внутри» относительно каждой из сторон треугольника. <br><br>
Если подтверждается, что точка внутри треугольника, значит, нормаль в пересечении — это просто нормаль плоскости. Пусть TraceRay вернет соответствующие значения, 
и больше никаких изменений вносить не нужно.
</font></p>
</body>
</html>