<html>
<body>
<p><font size = '10' face = 'Times New Roman'><strong>Отражения</strong></font></p>
<p><font size = '5' face = 'Times New Roman'>Мы уже говорили о зеркалоподобных поверхностях, но тогда речь шла только 
о придании им глянца. А можем ли мы использовать объекты, которые будут отражать на своей поверхности другие объекты? 
Можем, и в трассировщике сделать это будет просто. <br><br>
Разберем принцип работы зеркала. Когда мы смотрим в него, то видим отражаемые им лучи света. Как показано на рис. 5.2, 
они отражаются симметрично относительно нормали поверхности.
<center><img src = "C:/Program Files (x86)/Qt Project/RayTracing/files/theory/img/5.2.png"></center>
<center><strong>Рис. 5.2.</strong> Луч света отражается от зеркала в направлении, симметричном <br>
относительно нормали его поверхности </center><br>
Допустим, мы трассируем луч, и ближайшее пересечение происходит с зеркалом. Какого цвета будет этот луч? Это не цвет самого зеркала, 
потому что мы наблюдаем отраженный свет. Значит, нужно выяснить, откуда он исходит и каким цветом обладает. Для этого вычислим 
направление отраженного луча и определим цвет света, идущего из этого направления. <br><br>
В основном цикле для каждого пикселя мы создаем луч из камеры в сцену и вызываем TraceRay для определения цвета, который камера 
видит в этом направлении. Если TraceRay определяет, что камера видит зеркало, то этой функции нужно лишь вычислить направление 
отраженного луча. Так мы сможем определить цвет света, идущего из этого направления. Причем вызывать TraceRay должна саму себя. <br><br>
При создании рекурсивного алгоритма (вызывающего самого себя) нам нужно убедиться, что мы не порождаем бесконечный цикл 
(известный как «Программа не отвечает. Закрыть?»). У этого алгоритма есть два естественных условия выхода: 
когда луч сталкивается с неотражающим объектом и когда он ни с чем не сталкивается. Но есть простой случай, когда мы можем попасть 
в западню бесконечного цикла: эффект бесконечного коридора. Его можно увидеть, если поставить два зеркала напротив друг друга. <br><br>
Есть много способов предотвратить это. Но мы просто введем в алгоритм понятие <i>ограничения рекурсии</i>, которое поможет нам 
контролировать, насколько «глубоко» она может уйти. Назовем это ограничение <i>r</i>. Когда <i>r</i> = 0, мы видим объекты без отражений. 
Когда <i>r</i> = 1, мы видим объекты и отражения некоторых объектов в них (рис. 5.3).
<center><img src = "C:/Program Files (x86)/Qt Project/RayTracing/files/theory/img/5.3.png"></center>
<center><strong>Рис. 5.3.</strong>  Отражения некоторых объектов в других объектах (<i>r</i> = 1). Мы видим сферы, <br>
отраженные от других сфер, но сами они отражений не дают</center><br>
</font></p>
</body>
</html>